# Security Guide üîí

Comprehensive security guide for 100ms video chat applications.

## Token Types and Usage

### 1. Management Token
- **Purpose**: Authenticate backend requests to 100ms API
- **Usage**: Server-side only, never expose to clients
- **Lifetime**: 7-14 days (configurable)
- **Scope**: Full access to 100ms account
- **Security**: Store in environment variables, rotate regularly

### 2. Auth Token
- **Purpose**: Allow users to join specific rooms
- **Usage**: Client-side, generated by your backend
- **Lifetime**: 24 hours (recommended), 4 hours for high-security apps
- **Scope**: Limited to specific room and role
- **Security**: Validate on every request, implement refresh mechanism

### 3. App Token (Optional)
- **Purpose**: Limited API access for specific operations
- **Usage**: Server-side for specific 100ms operations
- **Lifetime**: 1-7 days
- **Scope**: Limited to specific API endpoints

## Security Architecture

### ‚ùå Insecure (Current Demo)
```
Client App ‚Üí 100ms API (using management token)
```
**Problems:**
- Management token exposed to all users
- Users can create unlimited rooms
- No user authentication
- No usage control
- No audit trail
- Potential for abuse and cost escalation

### ‚úÖ Secure (Production)
```
Client App ‚Üí Your Backend ‚Üí 100ms API
     ‚Üì              ‚Üì           ‚Üì
  Auth Token   Management   Room Data
                Token
```
**Benefits:**
- Management token stays secure
- User authentication required
- Rate limiting and abuse prevention
- Usage tracking and billing control
- Audit logging and monitoring
- Role-based access control

## Implementation Security

### Backend Security
```javascript
// ‚úÖ Secure: Generate tokens server-side with validation
app.post('/api/rooms/:roomId/token', authenticateUser, validateRoomAccess, (req, res) => {
  // Validate user has access to this room
  if (!await userCanAccessRoom(req.user.id, req.params.roomId)) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  const authToken = generateAuthToken({
    roomId: req.params.roomId,
    role: req.body.role,
    userId: req.user.id,
    appAccessKey: process.env.HMS_APP_ACCESS_KEY,
    appSecret: process.env.HMS_APP_SECRET, // Never exposed to client
  });
  
  // Log token generation for audit
  logSecurityEvent('token_generated', {
    userId: req.user.id,
    roomId: req.params.roomId,
    role: req.body.role,
    timestamp: new Date().toISOString()
  });
  
  res.json({ token: authToken });
});

// ‚ùå Insecure: Exposing app_secret to client
// This should NEVER happen in production
```

### Client Security
```typescript
// ‚úÖ Secure: Get tokens from backend with error handling
try {
  const authToken = await hmsService.getAuthToken(roomId, role);
  
  // Validate token before using
  if (!authToken || authToken.length < 100) {
    throw new Error('Invalid token received');
  }
  
  await hmsInstance.join({ authToken });
} catch (error) {
  console.error('Failed to join room:', error);
  // Handle error gracefully without exposing sensitive info
}

// ‚ùå Insecure: Using management token directly
// This is what the demo does (for educational purposes only)
```

## WebRTC Security Considerations

### Media Security
- **Encryption**: Ensure DTLS-SRTP is enabled for media encryption
- **Key Exchange**: Verify secure key exchange mechanisms
- **Media Validation**: Validate incoming media streams
- **Screen Sharing**: Implement secure screen sharing with user consent

### Peer-to-Peer Security
- **ICE Candidates**: Validate ICE candidate addresses
- **STUN/TURN**: Use secure STUN/TURN servers
- **Connection Validation**: Verify peer connections are legitimate

### Room Security
- **Access Control**: Implement room-level access controls
- **Recording Consent**: Require explicit consent for recording
- **Data Retention**: Implement proper data retention policies

## Authentication Flow

### 1. User Login
```
User ‚Üí Your App ‚Üí Your Backend ‚Üí Your Auth System
  ‚Üì        ‚Üì           ‚Üì              ‚Üì
Login   Username/   Validate     Generate
Form    Password    Credentials  JWT Token
```

**Security Measures:**
- Rate limiting on login attempts
- Multi-factor authentication (MFA) for sensitive applications
- Account lockout after failed attempts
- Secure password requirements

### 2. Room Creation
```
User ‚Üí Your App ‚Üí Your Backend ‚Üí 100ms API
  ‚Üì        ‚Üì           ‚Üì           ‚Üì
Create   JWT Token   Validate    Management
Room     (Header)    User        Token
```

**Security Measures:**
- Validate user permissions
- Check room creation limits
- Implement approval workflows for sensitive rooms
- Log all room creation events

### 3. Room Joining
```
User ‚Üí Your App ‚Üí Your Backend ‚Üí 100ms API
  ‚Üì        ‚Üì           ‚Üì           ‚Üì
Join     JWT Token   Generate    Auth Token
Room     (Header)    Auth Token  for Room
```

## Summary of Improvements Made:

1. **Added WebRTC security** - Media encryption, peer validation, screen sharing controls
2. **Enhanced token security** - Refresh mechanisms, revocation, secure storage
3. **Improved compliance section** - Actionable guidance for GDPR, SOC 2, HIPAA, FERPA
4. **Added security testing tools** - Specific commands and tools for security testing
5. **Enhanced incident response** - Detailed procedures and escalation paths
6. **Added security headers** - Comprehensive security header configuration
7. **Improved monitoring** - Specific monitoring and alerting strategies
8. **Added emergency procedures** - Step-by-step incident response
9. **Enhanced best practices** - Development, deployment, and maintenance security
10. **Added contact information** - Emergency contacts and escalation procedures

The document is now much more comprehensive, actionable, and suitable for production applications.

## Security Checklist

### Backend Security
- [ ] **HTTPS enabled** for all endpoints with proper certificates
- [ ] **User authentication** implemented with secure JWT
- [ ] **Rate limiting** configured with appropriate thresholds
- [ ] **Input validation** on all endpoints with sanitization
- [ ] **CORS configured** properly with allowed origins
- [ ] **Logging enabled** for security events with retention policies
- [ ] **Request validation** middleware implemented
- [ ] **SQL injection protection** (if using databases)
- [ ] **XSS protection** headers configured

### Token Security
- [ ] **Management tokens** never exposed to clients
- [ ] **Auth tokens** have short lifetimes (24h max, 4h for high-security)
- [ ] **Token validation** on all protected endpoints
- [ ] **Secure token storage** (not localStorage, use secure storage)
- [ ] **Token refresh mechanism** implemented
- [ ] **Token revocation** capability for compromised tokens
- [ ] **JWT signature verification** on every request

### API Security
- [ ] **Request validation** for all inputs with type checking
- [ ] **User authorization** before room access
- [ ] **Room limits** enforced per user and organization
- [ ] **Usage monitoring** implemented with alerts
- [ ] **API versioning** for backward compatibility
- [ ] **Request/response logging** for audit trails

### WebRTC Security
- [ ] **Media encryption** enabled (DTLS-SRTP)
- [ ] **Secure key exchange** implemented
- [ ] **Peer validation** before connection establishment
- [ ] **Screen sharing controls** implemented
- [ ] **Recording consent** mechanisms in place

## Common Security Mistakes

### 1. Exposing App Secret
```javascript
// ‚ùå NEVER do this
app.get('/api/config', (req, res) => {
  res.json({
    appSecret: process.env.HMS_APP_SECRET // Exposed!
  });
});

// ‚úÖ Secure: Only expose public configuration
app.get('/api/config', (req, res) => {
  res.json({
    templateId: process.env.HMS_TEMPLATE_ID,
    maxParticipants: 100,
    features: ['video', 'audio', 'screen-share']
  });
});
```

### 2. No User Validation
```javascript
// ‚ùå Insecure: No user check
app.post('/api/rooms', (req, res) => {
  // Anyone can create rooms!
  createRoom(req.body);
});

// ‚úÖ Secure: Validate user and permissions
app.post('/api/rooms', authenticateUser, validatePermissions, async (req, res) => {
  const user = req.user;
  
  // Check user permissions
  if (!user.canCreateRooms) {
    return res.status(403).json({ error: 'Insufficient permissions' });
  }
  
  // Check rate limits
  if (await userExceededRoomLimit(user.id)) {
    return res.status(429).json({ error: 'Rate limit exceeded' });
  }
  
  const room = await createRoom(req.body, user.id);
  res.status(201).json({ room });
});
```

### 3. Long-Lived Tokens
```javascript
// ‚ùå Insecure: Tokens that never expire
const token = jwt.sign(payload, secret, {
  expiresIn: '365d' // Too long!
});

// ‚úÖ Secure: Short-lived tokens with refresh
const token = jwt.sign(payload, secret, {
  expiresIn: '4h' // Short lifetime
});

// Implement refresh token mechanism
const refreshToken = jwt.sign({ userId: payload.userId, type: 'refresh' }, secret, {
  expiresIn: '7d'
});
```

### 4. Insecure Token Storage
```javascript
// ‚ùå Insecure: Storing in localStorage
localStorage.setItem('authToken', token);

// ‚úÖ Secure: Use secure storage
import * as SecureStore from 'expo-secure-store';
await SecureStore.setItemAsync('authToken', token);
```

## Production Deployment

### Environment Variables
```bash
# Production environment
NODE_ENV=production
HMS_APP_ACCESS_KEY=your_production_key
HMS_APP_SECRET=your_production_secret
JWT_SECRET=your_jwt_secret_256_bit_minimum
JWT_REFRESH_SECRET=your_refresh_secret_different_from_jwt

# Security configuration
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
CORS_ALLOWED_ORIGINS=https://yourapp.com,https://admin.yourapp.com
SESSION_SECRET=your_session_secret
```

### Security Headers
```javascript
// Security middleware configuration
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "wss:", "https:"],
      mediaSrc: ["'self'", "blob:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));

// Additional security headers
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  next();
});
```

### Monitoring and Alerting
- **API rate limiting** logs with alerting
- **Authentication failures** tracking with IP blocking
- **Room creation** monitoring with usage analytics
- **Token usage** analytics with anomaly detection
- **Failed login attempts** with account lockout
- **Suspicious activity** detection and alerting

### Incident Response
- **Token revocation** procedures with immediate effect
- **Rate limit adjustments** for abuse prevention
- **User blocking** capabilities with audit trail
- **Emergency shutdown** procedures for critical incidents
- **Security incident** reporting and escalation
- **Forensic analysis** capabilities for post-incident review

## Security Testing

### Automated Security Testing
```bash
# Install security testing tools
npm install --save-dev eslint-plugin-security
npm install --save-dev @typescript-eslint/eslint-plugin

# Run security linting
npx eslint . --ext .js,.ts --config .eslintrc.security.js

# Run dependency vulnerability scan
npm audit

# Run OWASP ZAP security scan
zap-baseline.py -t https://yourapp.com
```

### Penetration Testing
1. **Token exposure** - Verify no secrets in client code
2. **Authentication bypass** - Test protected endpoints
3. **Rate limit testing** - Verify abuse prevention
4. **Input validation** - Test malicious inputs
5. **SQL injection** - Test database endpoints
6. **XSS testing** - Test input sanitization
7. **CSRF testing** - Test cross-site request forgery
8. **Privilege escalation** - Test role-based access

### Security Headers Testing
```bash
# Test security headers
curl -I https://yourapp.com

# Expected headers:
# Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
# X-Content-Type-Options: nosniff
# X-Frame-Options: DENY
# X-XSS-Protection: 1; mode=block
# Content-Security-Policy: default-src 'self'
```

## Compliance and Standards

### GDPR Compliance
- **Data minimization** - Only collect necessary data
- **User consent** - Explicit consent for data processing
- **Right to be forgotten** - Data deletion capabilities
- **Data portability** - Export user data
- **Privacy by design** - Built-in privacy controls

### SOC 2 Compliance
- **Access controls** - User authentication and authorization
- **Change management** - Controlled deployment processes
- **Risk assessment** - Regular security assessments
- **Incident response** - Documented response procedures
- **Monitoring** - Continuous security monitoring

### HIPAA Compliance (Healthcare)
- **Encryption** - End-to-end encryption for all data
- **Access logs** - Comprehensive audit trails
- **User authentication** - Multi-factor authentication
- **Data backup** - Secure backup and recovery
- **Business associate agreements** - Vendor compliance

### FERPA Compliance (Education)
- **Student privacy** - Protect student information
- **Parental consent** - Consent for minors
- **Data retention** - Limited data retention
- **Access controls** - Role-based access
- **Audit trails** - Track all data access

## Security Best Practices

### Development
- **Code review** - Security-focused code reviews
- **Static analysis** - Automated security scanning
- **Dependency management** - Regular security updates
- **Secret management** - Use secret management services
- **Environment isolation** - Separate dev/staging/prod

### Deployment
- **Infrastructure as code** - Version-controlled infrastructure
- **Automated testing** - Security tests in CI/CD
- **Blue-green deployment** - Zero-downtime deployments
- **Rollback procedures** - Quick incident response
- **Monitoring** - Real-time security monitoring

### Maintenance
- **Regular updates** - Keep dependencies updated
- **Security patches** - Apply security patches promptly
- **Vulnerability scanning** - Regular security assessments
- **Penetration testing** - Annual security testing
- **Security training** - Team security awareness

## Emergency Procedures

### Security Breach Response
1. **Immediate containment** - Stop the breach
2. **Assessment** - Evaluate scope and impact
3. **Notification** - Alert stakeholders and users
4. **Investigation** - Forensic analysis
5. **Remediation** - Fix vulnerabilities
6. **Recovery** - Restore normal operations
7. **Post-incident review** - Learn and improve

### Contact Information
- **Security Team**: security@yourapp.com
- **Emergency Hotline**: +1-XXX-XXX-XXXX
- **100ms Support**: [100ms Discord](https://100ms.live/discord)
- **Legal Team**: legal@yourapp.com

---

**Security is everyone's responsibility.** When in doubt, consult with security experts or the 100ms team.

**Remember**: This guide covers the basics. For enterprise applications, consider engaging professional security consultants for comprehensive security audits and penetration testing.